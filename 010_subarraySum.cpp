//
// Created by 23116 on 2023/5/2.
//
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        //思路：哈希表，用一个哈希表来存储前缀和，如果前缀和为k，那么就说明有一个子数组的和为k，如果前缀和为k+nums[i],那么就说明有一个子数组的和为k
        // 这是因为如果一个子数组的和为k，那么这个子数组的所有子数组的和也都为k，如果为k+nums[i],包含这个子数组的子数组的和也都为k+nums[i]
        unordered_map<int,int> m;
        int sum=0;
        int count=0;
        m[0]=1;//这里的m[0]=1是因为如果sum-k==0,那么就说明有一个子数组的和为k，所以要初始化为1
        for(int i=0;i<nums.size();i++){
            sum+=nums[i];//m.end()是什么意思？？？
            if(m.find(sum-k)!=m.end())//这里的m.find(sum-k)!=m.end()是因为如果m.find(sum-k)!=m.end(),那么就说明有一个子数组的和为k，所以要加上这个子数组的个数
                count+=m[sum-k];
            m[sum]++;//这里的m[sum]++是因为如果m[sum]++,那么就说明有一个子数组的和为sum，所以要加上这个子数组的个数
        }
        return count;
    }
};
//假设有一个数组nums=[3,4,7,2,-3,1,4,2]，要求求出所有子数组和为k=7的个数。
//
//首先，定义一个unordered_map<int,int>类型的哈希表m，用来存储前缀和以及对应的前缀和出现的次数。初始化sum和count为0，m[0]为1，表示前缀和为0的子数组出现的次数为1。
//
//在循环遍历nums数组时，依次计算前缀和sum，并将其存储到哈希表m中。对于nums数组中的每个元素，计算当前位置的前缀和sum，然后判断哈希表m中是否存在前缀和为sum-k的元素，如果存在，
// 则说明前面存在一个前缀和pre_sum，使得pre_sum的值加上某些nums[i]的值等于k，也就是说，从pre_sum到当前位置的这一段子数组的和为k，所以此时需要将count加上m[sum-k]的值，
// 也就是从pre_sum到当前位置的这一段子数组的个数。最后，将m[sum]的值加1，表示当前位置的前缀和sum出现的次数加1。
//
//在这个例子中，遍历到i=0时，nums[0]=3，前缀和sum=3，哈希表m中不存在前缀和为sum-k=7-3=4的元素，所以count不变，m[3]的值为1。
//
//遍历到i=1时，nums[1]=4，前缀和sum=7，哈希表m中存在前缀和为sum-k=7-7=0的元素，即m[0]=1，所以此时count加上m[0]的值1，也就是表示从pre_sum=0到当前位置的这一段子数组的个数。最后，将m[7]的值加1，表示当前位置的前缀和sum出现的次数加1。
//
//遍历到i=2时，nums[2]=7，前缀和sum=14，哈希表m中存在前缀和为sum-k=14-7=7的元素，即m[7]=1，所以此时count加上m[7]的值1，也就是表示从pre_sum=7到当前位置的这一段子数组的个数。最后，将m[14]的值加1，表示当前位置的前缀和sum出现的次数加1。
//
//继续遍历数组中的其他元素，直到遍历完整个数组。在这个例子中，最后返回的count的值为2，表示一共有两个子数组的和为7。
//
//希望这个例子能够帮助您更好地理解上述过程。如果您有其他问题，请告诉我。